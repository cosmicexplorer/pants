#!/usr/bin/env bash
# Copyright 2014 Pants project contributors (see CONTRIBUTORS.md).
# Licensed under the Apache License, Version 2.0 (see LICENSE).

REPO_ROOT=$(cd $(dirname "${BASH_SOURCE[0]}") && pwd -P)

_interpreter_version_sentinel_file_path='.pants.d/.pants-python-version'

function clean_if_interpreter_changed() {
  _python_version_to_run="$1"

  if [[ -n "${_recursive_pants_shell_script_invocation:-}" ]]; then
    return 0
  fi

  _python_version_file="${REPO_ROOT}/${_interpreter_version_sentinel_file_path}"

  if [[ -f "$_python_version_file" ]]; then
    _prev_run_python_version="$(cat "$_python_version_file")"
    if [[ "$_python_version_to_run" == "$_prev_run_python_version" ]]; then
      return 0
    fi
  else
    cat >&2 <<EOF
${_interpreter_version_sentinel_file_path} not found in the buildroot.
Forcing an initial clean-all.
EOF
  fi

  export _recursive_pants_shell_script_invocation='y'
  cat >&2 <<EOF
Different Python interpreter version detected compared to the previous Pants run.
Clearing the cache and preparing a Python ${_python_version_to_run} run...
EOF
  ./pants clean-all
  echo "$_python_version_to_run" > "$_python_version_file"
  unset _recursive_pants_shell_script_invocation
}

# This bootstrap script runs pants from the live sources in this repo.
#
# Further support is added for projects wrapping pants with custom external extensions.  In the
# future this will work differently (see: https://github.com/pantsbuild/pants/issues/5), but
# currently pants extenders can invoke this script exporting a few environment variables to include
# the extension source and requirements for development purposes:
# WRAPPER_SRCPATH       This is a colon separated list of paths containing extension sourcecode.
# WRAPPER_REQUIREMENTS  This is a colon separated list of pip install compatible requirements.txt
#                       files.
#
# For example, with a wrapping project layed out like so:
# /src/wrapper/
#   src/main/python/
#     wrapper/
#       ...
#   dependencies/python/
#     BUILD
#     requirements.txt
#
# And a pantsbuild/pants clone like so:
# /src/pantsbuild-pants
#
# You could invoke pants in the wrapper with its custom extension enabled using a script like so:
# /src/wrapper/pants
# ==
# #!/usr/bin/env bash
# WRAPPER_REQUIREMENTS="/src/wrapper/dependencies/python/requirements.txt" \
# WRAPPER_SRCPATH=/src/wrapper/src/main/python \
#    exec /src/pantsbuild-pants/pants "$@"
#
# The script defaults to running with Python 3. To use a specific Python version,
# such as 3.7, prefix the script with `PY=python3.7`.

set -e

HERE=$(cd `dirname "${BASH_SOURCE[0]}"` && pwd)

# Set RUN_PANTS_FROM_PEX to non-empty to cause this wrapper script to delegate directly
# to ./pants.pex. We use this in CI to avoid bootstrapping in every shard.
if [[ -n "${RUN_PANTS_FROM_PEX}" ]]; then
  exec "${HERE}/pants.pex" "$@"
fi

# Otherwise, run directly from sources, bootstrapping if needed.

# Exposes:
# + activate_pants_venv: Activate a virtualenv for pants requirements, creating it if needed.
source ${HERE}/build-support/pants_venv

# Exposes:
# + bootstrap_native_code: Builds target-specific native engine binaries.
source ${HERE}/build-support/bin/native/bootstrap_code.sh

# Default to using Python 3 if not otherwise specified.
export PY="${PY:-python3}"

# Set interpreter constraints to exactly match the interpreter used for the venv, if not already set.
# Note that $PY only impacts which virtualenv we use for the parent Pants process; we must also set
# PANTS_PYTHON_SETUP_INTERPRETER_CONSTRAINTS to constrain spawned subprocesses such as tests. Without
# any interpreter constraints, when PY is set to Python 3 we get the _Py_Dealloc exception (#6985) as
# Pants will try to use Python 2 for subprocesses. Without setting minor version constraints, when using Python 3
# we could end up using a different Python minor version for subprocesses than we do for Pants.
py_major_minor_patch=$(${PY} -c 'import sys; print(".".join(map(str, sys.version_info[0:3])))')

# We can currently assume the CI environment does not switch python versions within a shard.
if [[ "${ONLY_USING_SINGLE_PYTHON_VERSION:-false}" != 'true' ]]; then
  clean_if_interpreter_changed "$py_major_minor_patch"
fi

export PANTS_PYTHON_SETUP_INTERPRETER_CONSTRAINTS="${PANTS_PYTHON_SETUP_INTERPRETER_CONSTRAINTS:-['CPython==${py_major_minor_patch}']}"

PANTS_EXE="${HERE}/src/python/pants/bin/pants_loader.py"

if [[ ! -z "${WRAPPER_REQUIREMENTS}" ]]; then
  REQUIREMENTS=(
    $(echo ${WRAPPER_REQUIREMENTS} | tr : ' ')
    ${REQUIREMENTS[@]}
  )
fi

PANTS_SRCPATH=(
  ${HERE}/src/python
)
if [[ ! -z "${WRAPPER_SRCPATH}" ]]; then
  PANTS_SRCPATH=(
    $(echo ${WRAPPER_SRCPATH} | tr : ' ')
    ${PANTS_SRCPATH[@]}
  )
fi
PANTS_SRCPATH="$(echo ${PANTS_SRCPATH[@]} | tr ' ' :)"

function exec_pants_bare() {
  # Redirect activation and native bootstrap to ensure that they don't interfere with stdout.
  activate_pants_venv 1>&2
  bootstrap_native_code 1>&2
  PYTHONPATH="${PANTS_SRCPATH}:${PYTHONPATH}" \
    exec python ${PANTS_EXE} "$@"
}

if [[ ! -z "${WRAPPER_REQUIREMENTS}" ]]; then
  log "*** Running pants with extra requirements: ${WRAPPER_REQUIREMENTS} ***"
fi
if [[ ! -z "${WRAPPER_SRCPATH}" ]]; then
  log "*** Running pants with extra sources ${WRAPPER_SRCPATH} ***"
fi

if [[ ! -z "$PANTS_DEV" && "$PANTS_DEV" -eq 0 ]]; then
  # Unexport PANTS_DEV if explicitly set to 0.
  export -n PANTS_DEV
else
  # We're running against a Pants clone.
  export PANTS_DEV=1
fi

exec_pants_bare "$@"
